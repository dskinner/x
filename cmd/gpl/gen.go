// +build ignore

// Gen generates pkgmap for standard library.
package main

import (
	"bytes"
	"fmt"
	"go/constant"
	"go/format"
	"go/importer"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"text/template"
)

const tmpl = `// File is automatically generated by gen.go. DO NOT EDIT.

package main
import(
  {{- range $pkg := .}}
  {{Import $pkg.Name $pkg.Path}}
  {{- end}}
)

var pkgmap = map[string]map[string]interface{}{
  {{- range $pkg := .}}
  "{{$pkg.Name}}": map[string]interface{}{
    {{- range $obj := $pkg.Exports}}
    "{{$obj.Name}}": {{Cast $obj}},
    {{- end}}
  },
  {{- end}}
}`

func main() {
	log.SetPrefix("gen: ")
	log.SetFlags(0)

	goroot := runtime.GOROOT()
	if goroot == "" {
		log.Fatal("GOROOT not available")
	}
	gosrc := filepath.Join(goroot, "src")

	var paths []string
	skip := regexp.MustCompile(`(^cmd|^debug|^go|^internal|^runtime|^syscall|^testing|^unsafe|^vendor)|(internal$|testdata$)`)
	filepath.Walk(gosrc, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			log.Fatal(err)
		}
		if info.IsDir() {
			rel, err := filepath.Rel(gosrc, path)
			if err != nil {
				log.Fatal(err)
			}

			if skip.MatchString(rel) {
				return filepath.SkipDir
			}
			paths = append(paths, rel)
		}
		return nil
	})

	// type Package struct {
	// *types.Package
	// Exports []types.Object
	// }
	// imports := make(map[string]Package)

	imports := make(map[string]struct {
		*types.Package
		Exports []types.Object
	})

	for _, path := range paths {
		typ, err := importer.Default().Import(path)
		if err != nil {
			continue
		}
		name := typ.Name()

		switch path {
		case "crypto/rand":
			name = "crand"
		case "html/template":
			name = "htemplate"
		}

		if p, ok := imports[name]; ok {
			log.Fatalf("import conflict with %q and %q\n", path, p.Path())
		}

		pkg := imports[name]
		pkg.Package = typ
		pkg.SetName(name)

		for _, objname := range pkg.Scope().Names() {
			obj := pkg.Scope().Lookup(objname)
			if obj.Exported() {
				switch obj.(type) {
				case *types.TypeName:
					continue
				}
				pkg.Exports = append(pkg.Exports, obj)
			}
		}

		if len(pkg.Exports) > 0 {
			imports[name] = pkg
		}
	}

	var buf bytes.Buffer
	err := template.Must(template.New("").Funcs(funcs).Parse(tmpl)).Execute(&buf, imports)
	if err != nil {
		log.Fatal(err)
	}
	bin, err := format.Source(buf.Bytes())
	if err != nil {
		log.Println(buf.String())
		log.Fatal(err)
	}
	if err := ioutil.WriteFile("pkgmap.go", bin, 0666); err != nil {
		log.Fatal(err)
	}
}

var funcs = template.FuncMap{
	"Import": func(name, path string) string {
		if name == filepath.Base(path) {
			return fmt.Sprintf("%q", path)
		}
		return fmt.Sprintf("%s %q", name, path)
	},
	"Cast": func(obj types.Object) string {
		format := "%s.%s"
		switch t := obj.(type) {
		case *types.Const:
			if v := t.Val(); v.Kind() == constant.Int && constant.BitLen(v) == 64 {
				if _, ok := constant.Int64Val(v); !ok {
					format = "uint64(%s.%s)"
				}
			}
		}
		return fmt.Sprintf(format, obj.Pkg().Name(), obj.Name())
	},
}
